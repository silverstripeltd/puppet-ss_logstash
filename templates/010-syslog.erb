filter {

    # try to parse the log entry as a syslog formatted entry
    grok {
    	# don't make new fields for unnamed captures
    	named_captures_only => true
    	overwrite => [ "host" ]
        match => { 'message' => '(%{SYSLOGTIMESTAMP:syslog_timestamp}|%{TIMESTAMP_ISO8601:syslog_timestamp}) %{SYSLOGHOST:host} %{DATA:log_type}(?:\#%{DATA:virtual_id})?(?:\[%{POSINT}\])?:? (?<short_message>.{,4096})' }
    }

    # CRON is just noise and auth sends it's own logs with the sshd/su etc in log_type
    if [log_type] in ["CRON", "auth"] {
        drop { }
    }

    date {
        match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss", "ISO8601" ]
    }

    if [log_type] in ["nginx", "apache"] {
        grok {
			# don't make new fields for unnamed captures
			named_captures_only => true
			# if first entry is matched, don't try the match
			break_on_match => true
			# without http_resp_usec - normally nginx
			match => { 'short_message' => '(?:%{IPORHOST:http_clientip}|-)(?:\,\s%{NOTSPACE:http_proxyip})* %{USER:http_ident} %{USER:http_auth} \[%{HTTPDATE}\] "(?:%{WORD:http_verb} %{NOTSPACE:http_url}(?: HTTP/%{NUMBER:http_httpversion})?|%{DATA:http_rawrequest})" %{NUMBER:http_response:int} (?:%{NUMBER:http_bytes:int}|-) "%{DATA:http_referrer}" "%{DATA:http_agent}"' }
			# with http_resp_usec  - normally nginx
			match => { 'short_message' => '(?:%{IPORHOST:http_clientip}|-)(?:\,\s%{NOTSPACE:http_proxyip})* %{USER:http_ident} %{USER:http_auth} \[%{HTTPDATE}\] "(?:%{WORD:http_verb} %{NOTSPACE:http_url}(?: HTTP/%{NUMBER:http_httpversion})?|%{DATA:http_rawrequest})" %{NUMBER:http_response:int} (?:%{NUMBER:http_bytes:int}|-) "%{DATA:http_referrer}" "%{DATA:http_agent}" (?:%{NUMBER:http_resp_usec:int})' }
        }
        if [http_url] {
            mutate {
                replace => { 'short_message' => '%{http_verb} %{http_url}' }
            }
        }
    }

    mutate {
        remove_field => [ "syslog_timestamp", "file", "protocol", "level", "offset", "file", "facility"]
    }
}
